# Mes Premiers Mots ‚Äì Project Overview and Code Archive

## Overview
Mes Premiers Mots is a touch-centric French vocabulary game built as a collection of static HTML screens with modular JavaScript and CSS. Kids drag, tap, and celebrate completing words while audio clips reinforce pronunciation.

## Project Data Structure
```
.
  .gitignore
  LICENSE
  README.md
  index.html
  mes-histoires-allcode.md
  sw-register.js
mode/
  index.html
  js/
    mode-select.js
  css/
    mode.css
celebration/
  index.html
  js/
    celebration.js
  css/
    celebration.css
settings/
  index.html
  js/
    settings.js
  css/
    settings.css
assets/
  audio/
    alphabet/
      FR/
        A.mp3
        B.mp3
        C.mp3
        D.mp3
        E.mp3
        F.mp3
        G.mp3
        H.mp3
        I.mp3
        J.mp3
        K.mp3
        L.mp3
        M.mp3
        N.mp3
        O.mp3
        P.mp3
        Q.mp3
        R.mp3
        S.mp3
        T.mp3
        U.mp3
        V.mp3
        W.mp3
        X.mp3
        Y.mp3
        Z.mp3
    words/
      FR/
        ABEILLE.mp3
        ANANAS.mp3
        ARBRE.mp3
        AVION.mp3
        BALLON.mp3
        BANANE.mp3
        BATEAU.mp3
        BIBERON.mp3
        BISCUIT.mp3
        BONBON.mp3
        BOUGIE.mp3
        BROCOLI.mp3
        CADENAS.mp3
        CAFE.mp3
        CAMION.mp3
        CAROTTE.mp3
        CERF.mp3
        CERISE.mp3
        CHAISE.mp3
        CHAMPI.mp3
        CHAT.mp3
        CHEVAL.mp3
        CHIEN.mp3
        CHOU.mp3
        CINQ.mp3
        COEUR.mp3
        COLOMBE.mp3
        COMETE.mp3
        CRAYON.mp3
        DAUPHIN.mp3
        DEUX.mp3
        DINDE.mp3
        DIX.mp3
        DRAGON.mp3
        EAU.mp3
        ECOLE.mp3
        ETOILE.mp3
        FEUILLE.mp3
        FLEUR.mp3
        FRAISE.mp3
        FROMAGE.mp3
        GLACE.mp3
        GUITARE.mp3
        HAMSTER.mp3
        HELICO.mp3
        HIBOU.mp3
        HUIT.mp3
        ILE.mp3
        JOUET.mp3
        KIWI.mp3
        LAIT.mp3
        LAMA.mp3
        LAPIN.mp3
        LEOPARD.mp3
        LICORNE.mp3
        LION.mp3
        LIVRE.mp3
        MAIS.mp3
        MAISON.mp3
        MANGUE.mp3
        MELON.mp3
        METRO.mp3
        MOTO.mp3
        MOUTON.mp3
        NEIGE.mp3
        OEIL.mp3
        OEUF.mp3
        OISEAU.mp3
        PAIN.mp3
        PIZZA.mp3
        PLAGE.mp3
        POIRE.mp3
        POMME.mp3
        POULE.mp3
        POUSSIN.mp3
        PUZZLE.mp3
        QUATRE.mp3
        RAT.mp3
        RENARD.mp3
        REQUIN.mp3
        ROSE.mp3
        SALADE.mp3
        SAPIN.mp3
        SCOOTER.mp3
        SEPT.mp3
        SIX.mp3
        SOLEIL.mp3
        SOURIS.mp3
        TAMBOUR.mp3
        TAXI.mp3
        TIGRE.mp3
        TOMATE.mp3
        TORTUE.mp3
        TRAIN.mp3
        TRAM.mp3
        UN.mp3
        VELO.mp3
        VOILIER.mp3
        ZEBRE.mp3
        tmp.txt
    SFX/
      BRAVO.mp3
      SUCCESS.mp3
      bubbles/
        bubble_01.mp3
        bubble_02.mp3
        bubble_03.mp3
        bubble_04.mp3
        bubble_05.mp3
js/
  confetti.js
  landing.js
game/
  index.html
  data/
    words-fr.json
  js/
    audio.mjs
    drag-drop.mjs
    main.mjs
    word-check.mjs
  css/
    game.css
css/
  base.css
  landing.css
```

> **Note:** Audio assets under `assets/audio/` are binary media files and are listed above for structure reference only.

## Code Listings

#### `.gitignore`
Defines ignored files and directories for Node- and web-focused tooling.

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
```

#### `LICENSE`
MIT license granting permission to use, modify, and distribute the project.

```
MIT License

Copyright (c) 2025 mattleouf

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

#### `README.md`
Design-focused project overview describing goals, gameplay, and structure.

```
# mes-premiers-mots
Mes Premiers Mots

Mes Premiers Mots is a touch-first, browser-based educational game designed for toddlers and preschool children (ages 3‚Äì5) to learn the French alphabet and basic vocabulary in a playful and accessible way. The design focuses on simplicity, clarity, and joyful interaction on mobile devices (iPhone/iPad).

‚∏ª

Game Design Overview

‚ú® Goal

Help young children recognize letters and form simple words associated with clear, colorful images ‚Äî all in French.

üü° Core Interaction
	‚Ä¢	The player is shown a picture (e.g., a cat).
	‚Ä¢	Below the image, the word (e.g., ‚ÄúCHAT‚Äù) appears in faint capital letters as empty letter boxes.
	‚Ä¢	Letter tiles (including distractors) are scattered around the screen.
	‚Ä¢	The player drags and drops or taps letters into the correct boxes to complete the word.

‚∏ª

Gameplay Design

Element	Design Purpose
Touch controls	Large touch areas (‚â•44px), responsive on iPhone and iPad, with both tap-to-place and drag-and-drop to suit young children‚Äôs motor skills.
Visual targets	Faint, outlined letters act as soft guidance without making the answer too obvious. Letters ‚Äúsnap‚Äù comfortably into place.
Positive reinforcement	Correct placement triggers gentle animations and sounds (e.g., a ‚Äúpop‚Äù or happy chime).
Negative feedback	Wrong placement gives immediate but soft feedback (e.g., shake effect, gentle ‚Äúnope‚Äù sound).
Completion celebration	When a word is completed, a short success animation plays, followed by a ‚ÄúNouveau mot‚Äù button to continue playing.
Word history        Each solved word's emoji appears at the bottom of the screen and stays for the session until returning to the start page.
Simple navigation	Only two main screens: Landing Page and Game. Options accessible via a gear icon (to skip puzzles, toggle settings).
No distractions	Minimal text, no advertisements, no popups‚Äîpure focus on the learning experience.


‚∏ª

Visual & Audio Design

Design Element	Guidelines
Color scheme	Bright, high-contrast backgrounds with soft gradients to create a welcoming atmosphere.
Typography	Sans-serif, uppercase letters for maximum legibility, avoiding overly stylized fonts.
Illustrations	Simple, vibrant images (WebP/AVIF) representing common words children recognize.
Animations	Subtle, low-framerate-friendly animations for snaps, shakes, and success fireworks.
Sound effects	Short, clear sounds to reinforce correct/incorrect actions without being overwhelming. Optional pronunciation audio clips after success.


Updated Visual Feedback Instructions
        ‚Ä¢       Tile Drag/Select Animation: when a tile is picked up or tapped, scale it up slightly and grow its shadow to show it is lifted.
        ‚Ä¢       Slot Hover Feedback: hovering over any free slot should highlight it with a brighter border or background so the drop zone is obvious.
        ‚Ä¢       Incorrect Drop Feedback: if a tile is released on the wrong slot, the slot outline briefly flashes red, the tile shakes then returns to its original position, and a short negative audio cue plays.


‚∏ª

Structure of the Game Flow
	1.	Landing Page
‚ÄúMes Premiers Mots‚Äù title ‚Üí Jouer ‚Üí Options
Goal: Clear entry point, no friction to start playing.
	2.	Game Screen
	‚Ä¢	Picture at the top.
	‚Ä¢	Faint letter boxes showing the word underneath.
	‚Ä¢	Scattered letter tiles in a lower pool.
	‚Ä¢	Drag or tap letters into boxes.
	‚Ä¢	Soft correction, celebration, and flow to the next word.
	3.	Options Menu
Planned settings:
	‚Ä¢	Skip puzzle
	‚Ä¢	Toggle ‚Äúfaint letters‚Äù visibility
	‚Ä¢	Sound on/off
	‚Ä¢	Word difficulty (future)

‚∏ª

Design Priorities
	‚Ä¢	Immediate feedback: Every action produces a clear, positive or negative response.
	‚Ä¢	Repetitive loop with variety: Word changes frequently, reinforcing vocabulary.
	‚Ä¢	Minimal frustration: Generous hitboxes, forgiving interactions, no penalties.
	‚Ä¢	Instant play: No loading screens, no accounts, no downloads‚Äîtap the link and play.
	‚Ä¢	Mobile-first design: Prioritized for Safari on iPhone/iPad, but responsive on any modern browser.

‚∏ª

Project Layout (Design-Centered Structure)

mes-premiers-mots/
‚îú‚îÄ‚îÄ index.html          ‚Üê landing page (start/options)
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îú‚îÄ‚îÄ base.css        ‚Üê resets, variables (colors, spacing)
‚îÇ   ‚îî‚îÄ‚îÄ landing.css     ‚Üê landing page visuals
‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îî‚îÄ‚îÄ landing.js      ‚Üê landing screen logic
‚îú‚îÄ‚îÄ game/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ css/game.css    ‚Üê main game visuals
‚îÇ   ‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.mjs        ‚Üê game loop
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ drag-drop.mjs   ‚Üê touch & pointer handling
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word-check.mjs  ‚Üê validation logic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ audio.mjs       ‚Üê sound effects
‚îÇ   ‚îú‚îÄ‚îÄ data/words-fr.json ‚Üê word list (edit to add/remove words)
‚îÇ   ‚îî‚îÄ‚îÄ assets/
‚îÇ       ‚îú‚îÄ‚îÄ img/            ‚Üê pictures
‚îÇ       ‚îî‚îÄ‚îÄ sfx/            ‚Üê sound effects


‚∏ª

Design Choices for Simplicity
	‚Ä¢	Two HTML pages (landing + game): minimal load, instant switching.
	‚Ä¢	Modular JS (ES Modules): easy to expand features (e.g., audio, new interactions) without bloating files.
	‚Ä¢	Separation of visuals and logic: CSS for layout, JS for interactions, JSON for words = clarity and easy maintenance.
	‚Ä¢	No dependencies: Vanilla JS and CSS only. Clean code, fast load.

‚∏ª

Expansion Possibilities (Design-Focused)

Feature	Design Approach
More words	Easily added via JSON, no code changes.
Theme modes	Color variables in CSS for quick swaps.
Difficulty settings	Hide letter hints, increase distractors.
Language packs	Structure supports adding English/Spanish words easily.
Offline-ready   A service worker caches assets after the first visit so the game works offline.


‚∏ª

Summary

Mes Premiers Mots is designed around clarity, joyful feedback, and accessibility for young learners. It prioritizes simplicity, instant play, and fun repetition to encourage early reading skills without unnecessary distractions.

This repository exists to structure development cleanly, with each element (visual, logic, content) clearly separated and easy to modify as the game evolves.

‚∏ª

License

MIT ‚Äî open educational resource, free to use and expand.
```

#### `index.html`
Touch-first landing page with animated tiles, preload overlay, and navigation buttons.

```
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mes Premiers Mots</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/base.css">
  <link rel="stylesheet" href="css/landing.css">
</head>
<body>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
  <div class="flying-tile" aria-hidden="true"></div>
    <div class="container">
      <h1 class="title titan-one-regular">
        <span class="small">MES</span>
        <span class="medium">PREMIERS</span>
      </h1>
      <div class="title-tiles">
        <div class="title-tile">M</div>
        <div class="title-tile">O</div>
        <div class="title-tile">T</div>
        <div class="title-tile">S</div>
      </div>
      <div class="buttons">
        <button id="play" class="btn play">Jouer</button>
        <button id="options" class="btn options">Options</button>
      </div>
    </div>
  <div id="loading-overlay" class="loading-overlay hidden">
    <div class="container">
      <h1 class="title titan-one-regular">
        <span class="small">MES</span>
        <span class="medium">PREMIERS</span>
      </h1>
      <div class="title-tiles">
        <div class="title-tile">M</div>
        <div class="title-tile">O</div>
        <div class="title-tile">T</div>
        <div class="title-tile">S</div>
      </div>
      <div class="loading-bar"><div id="loading-progress" class="loading-progress"></div></div>
      <div id="loading-text" class="loading-text">0%</div>
    </div>
  </div>
  <script src="js/landing.js"></script>
  <script src="sw-register.js"></script>
</body>
</html>
```

#### `sw-register.js`
Unregisters any active service workers to disable caching.

```
// Disable service worker caching by unregistering any existing workers
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then((registrations) => {
    registrations.forEach((registration) => registration.unregister());
  });
}
```

#### `css/base.css`
Global font declarations and shared button styling.

```
/* Base styles: resets, fonts */
body { margin: 0; font-family: sans-serif; }

/* Font for the animated title */
.bungee-regular {
  font-family: "Bungee", sans-serif;
  font-weight: 400;
  font-style: normal;
}

/* Titan One font for the title */
.titan-one-regular {
  font-family: "Titan One", sans-serif;
  font-weight: 400;
  font-style: normal;
}

/* Nunito font for buttons and menus */
.nunito-regular {
  font-family: "Nunito", sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
}

/* Shared button styles */
.btn {
  font-family: "Nunito", sans-serif;
  font-size: 1.25rem;
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 8px;
  cursor: pointer;
}

.btn:hover {
  opacity: 0.9;
}

.play {
  background-color: #4caf50;
  color: #fff;
}

.options {
  background-color: #2196f3;
  color: #fff;
}
```

#### `css/landing.css`
Landing page layout, animated title tiles, and loading overlay visuals.

```
/* Landing page styling */
body {
  background: #f7f7f5;
  height: 100dvh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  user-select: none;
}

.container {
  text-align: center;
  padding: 2rem;
  position: relative;
  z-index: 1;
}



/* animated heading */
.title {
  margin-bottom: 0;
  color: #ff9966;
}

.title span {
  display: block;
  line-height: 1;
}

.title .small {
  font-size: clamp(2rem, 6vw, 3rem);
}

.title .medium {
  font-size: clamp(3rem, 8vw, 4.5rem);
}

.title-tiles {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-top: 0;
}

.title-tile {
  width: clamp(60px, 6vw, 120px);
  height: clamp(60px, 6vw, 120px);
  background: #fdfdfd;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(2rem, 4vw, 4rem);
  color: #000;
  user-select: none;
}

@keyframes color-cycle {
  0% { color: #ff9999; }
  33% { color: #ffb366; }
  66% { color: #fff2a8; }
  100% { color: #ff9999; }
}


.buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: center;
  margin-top: clamp(2rem, 8vh, 8rem);
}

.buttons .btn {
  font-size: clamp(1.25rem, 2vw, 2.5rem);
  padding: clamp(0.75rem, 1vw, 1.5rem) clamp(1.5rem, 2vw, 3rem);
}


.loading-overlay {
  position: fixed;
  inset: 0;
  background: #f7f7f5;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  z-index: 5;
}

.loading-overlay.hidden {
  display: none;
}

.loading-bar {
  width: 60%;
  height: 10px;
  background: #ddd;
  border-radius: 5px;
  overflow: hidden;
  margin: 1rem auto 0;
}

.loading-progress {
  height: 100%;
  width: 0;
  background: #4caf50;
  transition: width 0.2s ease;
}

.loading-text {
  margin-top: 0.5rem;
  font-family: "Nunito", sans-serif;
}

.flying-tile {
  position: fixed;
  top: 0;
  left: 0;
  width: 90px;
  height: 90px;
  background: #f7f7f5;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3rem;
  font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
  color: #000;
  z-index: 0;
  pointer-events: none;
  overflow: hidden;
  line-height: 1;
  user-select: none;
}

/* Breakpoints for very wide screens */
@media (min-width: 1600px) {
  .buttons {
    flex-direction: row;
    gap: 2rem;
  }
}

@media (min-width: 2200px) {
  .title-tile {
    width: clamp(90px, 4vw, 150px);
    height: clamp(90px, 4vw, 150px);
    font-size: clamp(3rem, 3vw, 5rem);
  }

  .buttons .btn {
    font-size: clamp(2rem, 1.5vw, 3rem);
    padding: clamp(1rem, 1vw, 2rem) clamp(2rem, 2vw, 4rem);
  }
}

```

#### `js/confetti.js`
DOM-driven confetti utility that returns a stop function for celebrations.

```
// DOM-based confetti effect inspired by https://codepen.io/wakana-k/pen/gOqqWdY
// Exports startConfetti which returns a stop function.

const COLORS = ['#fce18a', '#ff726d', '#b48def', '#f4306d'];
const INTERVAL = 150;

export function startConfetti(container = document.body) {
  ensureStyles();
  const wrapper = document.createElement('div');
  wrapper.className = 'wk-confetti';
  container.appendChild(wrapper);

  function addPiece() {
    const piece = document.createElement('span');
    piece.className = 'wk-confetti-piece';
    piece.style.left = Math.random() * 100 + '%';
    piece.style.setProperty('--color', COLORS[Math.floor(Math.random() * COLORS.length)]);
    piece.style.setProperty('--sway', (Math.random() * 60 - 30) + 'px');
    piece.style.setProperty('--rotate', (Math.random() < 0.5 ? '-' : '') + '720deg');
    piece.style.setProperty('--duration', 4 + Math.random() * 2 + 's');
    wrapper.appendChild(piece);
    piece.addEventListener('animationend', () => piece.remove());
  }

  for (let i = 0; i < 20; i++) addPiece();
  const timer = setInterval(addPiece, INTERVAL);

  return function stop() {
    clearInterval(timer);
    wrapper.remove();
  };
}

function ensureStyles() {
  if (document.getElementById('wk-confetti-style')) return;
  const style = document.createElement('style');
  style.id = 'wk-confetti-style';
  style.textContent = `
    .wk-confetti { position: fixed; inset: 0; pointer-events: none; overflow: hidden; }
    .wk-confetti-piece {
      position: absolute;
      top: -10px;
      width: 10px;
      height: 10px;
      background-color: var(--color);
      opacity: 0.9;
      transform: rotate(45deg);
      animation: wk-confetti-fall var(--duration) linear forwards;
    }
    @keyframes wk-confetti-fall {
      0% { transform: translateX(0) translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateX(var(--sway)) translateY(100vh) rotate(var(--rotate)); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
}
```

#### `js/landing.js`
Landing screen logic: floating emoji tiles, resource prefetch, and navigation.

```
// Landing page interactions
window.addEventListener('DOMContentLoaded', async () => {
  // Reset word history when returning to the start screen
  sessionStorage.removeItem('wordHistory');
  const play = document.getElementById('play');
  const options = document.getElementById('options');
  const overlay = document.getElementById('loading-overlay');
  const progressBar = document.getElementById('loading-progress');
  const progressText = document.getElementById('loading-text');
  const tiles = Array.from(document.querySelectorAll('.flying-tile'));

  const size = 90; // match CSS

  const wordData = await fetch('game/data/words-fr.json').then((r) => r.json());
  const emojis = wordData.map((w) => w.emoji);

  const randomEmoji = () => emojis[Math.floor(Math.random() * emojis.length)];
  // Slightly faster movement than before
  const randomVelocity = () =>
    (Math.random() * 0.4 + 0.2) * 1.2 * (Math.random() < 0.5 ? -1 : 1);

  const states = [];

  const resources = [
    'mode/index.html',
    'mode/css/mode.css',
    'mode/js/mode-select.js',
    'game/index.html',
    'game/css/game.css',
    'game/js/main.mjs',
    'game/js/drag-drop.mjs',
    'game/js/word-check.mjs',
    'game/js/audio.mjs',
    'game/data/words-fr.json',
    'settings/index.html',
    'settings/css/settings.css',
    'settings/js/settings.js',
    'celebration/index.html',
    'celebration/css/celebration.css',
    'celebration/js/celebration.js',
    'js/confetti.js'
  ];

  async function prefetchResources() {
    overlay.classList.remove('hidden');
    let loaded = 0;
    const update = () => {
      loaded++;
      const pct = Math.round((loaded / resources.length) * 100);
      progressBar.style.width = pct + '%';
      progressText.textContent = pct + '%';
    };

    await Promise.all(
      resources.map(async (url) => {
        try {
          await fetch(url);
        } catch (e) {
          // ignore failures (offline or 404)
        }
        update();
      })
    );
    overlay.classList.add('hidden');
  }

  const nonOverlappingPosition = () => {
    for (let attempt = 0; attempt < 50; attempt++) {
      const x = Math.random() * (window.innerWidth - size);
      const y = Math.random() * (window.innerHeight - size);
      let overlap = false;
      for (const s of states) {
        if (Math.abs(s.x - x) < size && Math.abs(s.y - y) < size) {
          overlap = true;
          break;
        }
      }
      if (!overlap) return { x, y };
    }
    return { x: Math.random() * (window.innerWidth - size), y: Math.random() * (window.innerHeight - size) };
  };

  const uniqueEmojis = [...emojis]
    .sort(() => Math.random() - 0.5)
    .slice(0, tiles.length);

  tiles.forEach((tile, idx) => {
    const pos = nonOverlappingPosition();
    tile.textContent = uniqueEmojis[idx];
    tile.style.transform = `translate(${pos.x}px, ${pos.y}px)`;
    states.push({
      x: pos.x,
      y: pos.y,
      vx: randomVelocity(),
      vy: randomVelocity(),
    });
  });

  const step = () => {
    const maxX = window.innerWidth - size;
    const maxY = window.innerHeight - size;

    // move and bounce on edges
    states.forEach((s, idx) => {
      s.x += s.vx;
      s.y += s.vy;

      if (s.x <= 0 || s.x >= maxX) {
        s.vx *= -1;
        s.x = Math.max(0, Math.min(s.x, maxX));
        tiles[idx].textContent = randomEmoji();
      }
      if (s.y <= 0 || s.y >= maxY) {
        s.vy *= -1;
        s.y = Math.max(0, Math.min(s.y, maxY));
        tiles[idx].textContent = randomEmoji();
      }
    });

    // collisions between tiles (simple elastic swap)
    for (let i = 0; i < states.length; i++) {
      for (let j = i + 1; j < states.length; j++) {
        const a = states[i];
        const b = states[j];
        if (Math.abs(a.x - b.x) < size && Math.abs(a.y - b.y) < size) {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          if (Math.abs(dx) > Math.abs(dy)) {
            const overlap = size - Math.abs(dx);
            if (dx > 0) {
              a.x += overlap / 2;
              b.x -= overlap / 2;
            } else {
              a.x -= overlap / 2;
              b.x += overlap / 2;
            }
            const tmp = a.vx;
            a.vx = b.vx;
            b.vx = tmp;
          } else {
            const overlap = size - Math.abs(dy);
            if (dy > 0) {
              a.y += overlap / 2;
              b.y -= overlap / 2;
            } else {
              a.y -= overlap / 2;
              b.y += overlap / 2;
            }
            const tmp = a.vy;
            a.vy = b.vy;
            b.vy = tmp;
          }
        }
      }
    }

    tiles.forEach((tile, i) => {
      const s = states[i];
      tile.style.transform = `translate(${s.x}px, ${s.y}px)`;
    });

    requestAnimationFrame(step);
  };

  requestAnimationFrame(step);

  const PREFETCH_VERSION = 'mpm-cache-v2';
  if (localStorage.getItem('prefetched') !== PREFETCH_VERSION) {
    await prefetchResources();
    localStorage.setItem('prefetched', PREFETCH_VERSION);
  } else {
    overlay.classList.add('hidden');
  }

  play.addEventListener('click', () => {
    window.location.href = 'mode/';
  });
  options.addEventListener('click', () => {
    window.location.href = 'settings/';
  });
});
```

#### `mode/index.html`
Mode selection page presenting session length presets.

```
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Choix du mode</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/base.css">
  <link rel="stylesheet" href="../css/landing.css">
  <link rel="stylesheet" href="css/mode.css">
</head>
<body>
  <div class="container">
    <h1 class="title titan-one-regular">Choisis un mode</h1>
    <div class="modes">
      <div class="mode-option">
        <div class="preview" aria-hidden="true"></div>
        <button class="btn play mode-btn" data-count="3" data-emoji="‚ö°" style="--clr:#ffca28">
          Test<br><small>3 mots</small>
        </button>
      </div>
      <div class="mode-option">
        <div class="preview" aria-hidden="true"></div>
        <button class="btn play mode-btn" data-count="7" data-emoji="üå±" style="--clr:#81c784">
          Court<br><small>7 mots</small>
        </button>
      </div>
      <div class="mode-option">
        <div class="preview" aria-hidden="true"></div>
        <button class="btn play mode-btn" data-count="15" data-emoji="üåø" style="--clr:#4caf50">
          Moyen<br><small>15 mots</small>
        </button>
      </div>
      <div class="mode-option">
        <div class="preview" aria-hidden="true"></div>
        <button class="btn play mode-btn" data-count="30" data-emoji="üå≥" style="--clr:#42a5f5">
          Long<br><small>30 mots</small>
        </button>
      </div>
      <div class="mode-option">
        <div class="preview" aria-hidden="true"></div>
        <button class="btn play mode-btn" data-count="inf" data-emoji="‚ôæÔ∏è" style="--clr:#ab47bc">
          Infini<br><small>sans fin</small>
        </button>
        </div>
      </div>
      <button id="back" class="btn options back-btn">Retour</button>
  </div>
  <script type="module" src="js/mode-select.js"></script>
  <script src="../sw-register.js"></script>
</body>
</html>
```

#### `mode/css/mode.css`
Responsive layout and animations for mode selection buttons.

```
.modes {
  margin-top: 4vh;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 1rem;
  justify-items: center;
}

.mode-option {
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #fdfdfd;
  border-radius: 12px;
  padding: 0.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.mode-btn {
  position: relative;
  user-select: none;
  width: 100%;
  background-color: var(--clr, #4caf50);
  color: #fff;
  transition: transform 0.2s, box-shadow 0.2s;
}

.mode-btn:hover {
  transform: scale(1.05);
}

.mode-btn.selected {
  animation: pop 0.3s ease;
}

@keyframes pop {
  0% { transform: scale(1); box-shadow: none; }
  50% { transform: scale(1.1); box-shadow: 0 0 10px rgba(0,0,0,0.2); }
  100% { transform: scale(1); box-shadow: none; }
}

.mode-btn small {
  display: block;
  font-size: 1rem;
}

.preview {
  font-size: 3rem;
  user-select: none;
  line-height: 1;
}

body {
  height: auto;
  min-height: 100dvh;
  overflow-y: auto;
  padding-top: 2vh;
}

.container {
  display: flex;
  flex-direction: column;
  min-height: 100dvh;
}

.back-btn {
  margin-top: auto;
  align-self: center;
  margin-bottom: 2rem;
}
```

#### `mode/js/mode-select.js`
Stores chosen session length and navigates to the game.

```
window.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.mode-btn').forEach((btn) => {
    const countAttr = btn.dataset.count;
    const preview = btn.parentElement.querySelector('.preview');
    if (preview) {
      preview.textContent = btn.dataset.emoji || '';
    }
    btn.addEventListener('click', () => {
      sessionStorage.setItem('wordLimit', countAttr);
      btn.classList.add('selected');
      setTimeout(() => {
        window.location.href = '../game/';
      }, 300);
    });
  });
  document.getElementById('back').addEventListener('click', () => {
    window.location.href = '../';
  });
});
```

#### `game/index.html`
Main gameplay shell with start overlay, settings modal, and next-word control.

```
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jeu - Mes Premiers Mots</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/base.css">
  <link rel="stylesheet" href="../css/landing.css">
  <link rel="stylesheet" href="css/game.css">
</head>
<body>
  <div id="start-overlay" class="start-overlay">
    <div class="word-select">
      <h1 class="title titan-one-regular">Choisis ton premier mot</h1>
      <div id="word-choices" class="word-choices"></div>
    </div>
  </div>
  <div class="game-layout">
    <div id="picture" aria-label="Illustration"></div>
    <div id="word" class="word"></div>
    <div id="tiles" class="tiles"></div>
  </div>
  <div id="confetti" class="confetti-container"></div>
  <div id="message" class="message"></div>
  <div id="history" class="history"></div>
  <button id="settings-btn" class="settings-btn" aria-label="Param√®tres">‚öôÔ∏è</button>
  <div id="settings-modal" class="settings-modal hidden" role="dialog" aria-modal="true" aria-labelledby="settings-title">
    <div class="modal-content">
      <h2 id="settings-title">Param√®tres</h2>
      <button id="continue-btn" class="btn play">Continuer</button>
      <button id="skip-btn" class="btn options">Passer ce mot</button>
      <button id="menu-btn" class="btn options">Retour au menu</button>
    </div>
  </div>
  <button id="next" class="next btn play" style="display:none;">Mot suivant <span aria-hidden="true">‚û°Ô∏è</span></button>
  <script type="module" src="js/main.mjs"></script>
  <script src="../sw-register.js"></script>
</body>
</html>
```

#### `game/css/game.css`
Game board styling, tile animations, history bar, and modal visuals.

```
/* Game screen styling */
:root {
  --tile-width: clamp(40px, 10vmin, 80px);
  --tile-height: clamp(50px, 12vmin, 100px);
  --tile-font: clamp(2rem, 5vmin, 3rem);
  --picture-size: clamp(8rem, 25vmin, 16rem);
  --btn-font: clamp(1.2rem, 3vmin, 1.6rem);
  --tiles-height: min(35vh, 80vmin);
}

body {
  text-align: center;
  padding-top: 0.5rem;
  overflow: hidden; /* prevent page scrolling during gameplay */
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #f7f7f5;
  user-select: none;
}
.game-layout {
  display: flex;
  flex-direction: column;
  align-items: center;
  transform-origin: top center;
}
#picture {
  /* enlarge the emoji display */
  font-size: var(--picture-size);
  /* reduced spacing to bring word closer to the top */
  margin-bottom: 1rem;
}
.word {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 2rem;
}
.slot {
  width: var(--tile-width);
  height: var(--tile-height);
  border: 2px dashed #555;
  border-radius: 6px;
  font-size: var(--tile-font);
  display: flex;
  align-items: center;
  justify-content: center;
  color: #000;
  user-select: none;
}
.slot.preview {
  opacity: 0.3;
}
.slot.filled {
  border-style: solid;
}
.tiles {
  position: relative;
  height: var(--tiles-height);
  width: min(calc(100vw - 2 * var(--tile-width)), calc(var(--tile-width) * 12));
  margin: 0 auto;
}

@media (orientation: landscape) {
  .tiles {
    margin: 0;
  }
}
.tile {
  width: var(--tile-width);
  height: var(--tile-height);
  background: #fdfdfd;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: var(--tile-font);
  cursor: grab;
  position: absolute;
  user-select: none;
}
.tile.active {
  box-shadow: 0 6px 10px rgba(0,0,0,0.4);
  z-index: 1;
}
.tile.shake {
  animation: shake 0.25s;
}
.slot.hover {
  box-shadow: 0 0 0 6px rgba(255, 165, 0, 0.9);
  border-color: #ffa500;
  background-color: rgba(255, 200, 0, 0.25);
}
.slot.wrong {
  animation: flash-red 0.3s;
}
.slot.flash-letter {
  animation: flash-letter-red 0.3s;
}
#next {
  position: fixed;
  bottom: clamp(8rem, 16vh, 10rem);
  right: 50%;
  transform: translateX(50%);
  z-index: 2;
}

/* button styles moved to base.css */
.btn {
  font-size: var(--btn-font);
}

.slot.placed {
  animation: pop 0.3s ease;
}

@keyframes pop {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}

#message {
  font-size: clamp(2rem, 10vw, 5rem);
  font-weight: 900;
  margin-top: 1rem;
  display: none;
  pointer-events: none;
  position: fixed;
  left: 50%;
  top: clamp(0.5rem, 8vh, 3rem);
  transform: translateX(-50%);
  white-space: nowrap;
  z-index: 2;
}

#message.show {
  display: block;
  animation: popIn 0.3s ease-out;
}


.confetti-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

.confetti {
  position: absolute;
  top: -10px;
  font-size: 2.5rem;
  animation: fall var(--duration, 4s) linear forwards;
  left: var(--x, 0);
  transform: translateX(0);
}

@keyframes fall {
  0% {
    transform: translateX(0) translateY(0) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateX(var(--sway, 0)) translateY(100vh) rotate(var(--rotate, 360deg));
    opacity: 0;
  }
}

#picture.animate {
  animation: bounce 0.6s ease-in-out infinite alternate;
}

@keyframes bounce {
  from { transform: scale(0.9); }
  to { transform: scale(1.3); }
}

@keyframes popIn {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
  70% { transform: translate(-50%, -50%) scale(1.3); opacity: 1; }
  100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}

.tile.drop {
  animation: tile-fall var(--duration, 1.6s) cubic-bezier(0.2, 0.8, 0.4, 1) var(--delay, 0s) forwards;
}

@keyframes tile-fall {
  to {
    transform: translateY(120vh) rotate(var(--spin, 45deg));
    opacity: 0;
  }
}

@keyframes shake {
  0%, 100% { transform: translate(0, 0); }
  25% { transform: translate(-4px, 0); }
  50% { transform: translate(4px, 0); }
  75% { transform: translate(-4px, 0); }
}

@keyframes flash-red {
  from { box-shadow: 0 0 0 4px red; }
  to { box-shadow: 0 0 0 4px transparent; }
}

@keyframes flash-letter-red {
  from { color: red; }
  to { color: #000; }
}

/* Word history at bottom of screen */
.history {
  position: fixed;
  bottom: 0.5rem;
  left: 50%;
  transform: translateX(-50%);
  display: grid;
  grid-template-columns: repeat(10, auto);
  gap: 0.25rem 0.5rem;
  max-width: 100%;
  pointer-events: none;
}

.history-emoji,
.history-placeholder {
  width: clamp(1.3rem, 2.5vw, 2.1rem);
  height: clamp(1.3rem, 2.5vw, 2.1rem);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(1.3rem, 2.5vw, 2.1rem);
  user-select: none;
}

.history-placeholder {
  opacity: 0.5;
  border: 1px solid #bbb;
  border-radius: 4px;
  box-sizing: border-box;
}

/* Settings button */
.settings-btn {
  position: fixed;
  top: clamp(0.25rem, 2vh, 1rem);
  right: clamp(0.25rem, 2vw, 1rem);
  background: none;
  border: none;
  font-family: "Nunito", sans-serif;
  font-size: clamp(1.6rem, 4vw, 3rem);
  cursor: pointer;
  z-index: 3;
}

/* Modal overlay */
.settings-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 4;
}

.settings-modal.hidden {
  display: none;
}

.settings-modal .modal-content {
  background: #fff;
  padding: 2rem;
  border-radius: 8px;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* button styles moved to base.css */

#menu-btn {
  background-color: #f44336;
  color: #fff;
}

@media (orientation: landscape) {
  body {
    padding-top: 1rem;
  }
  .game-layout {
    flex-direction: row;
    align-items: flex-start;
    justify-content: space-evenly;
  }
  #picture {
    margin-right: 2rem;
    margin-bottom: 0;
  }
  .word {
    margin-bottom: 1rem;
  }
  :root {
    --tiles-height: min(50vh, 80vmin);
  }
}

@media (min-width: 1200px) {
  #next {
    bottom: clamp(2rem, 10vh, 6rem);
  }
  .settings-btn {
    top: clamp(1rem, 2vh, 2rem);
    right: clamp(1rem, 2vw, 2rem);
  }
}

body.fade-out {
  animation: screen-out 0.5s ease forwards;
}

body.word-fade-out {
  animation: word-out 0.2s ease forwards;
}

body.word-fade-in {
  animation: word-in 0.2s ease;
}

@keyframes screen-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes word-out {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes word-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.start-overlay {
  position: fixed;
  inset: 0;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 5;
}

.start-overlay.hidden {
  display: none;
}

.word-select {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.word-choices {
  margin-top: 2rem;
  display: grid;
  grid-template-columns: repeat(2, minmax(160px, 1fr));
  gap: 1rem;
}

.word-option {
  display: flex;
  align-items: center;
  justify-content: center;
}

.word-btn {
  width: 100%;
  height: 100%;
  padding: 0;
  font-size: 5rem;
  background-color: #fff;
  border: none;
  border-radius: 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s, background 0.3s;
}

.word-btn:hover {
  transform: scale(1.05);
}

.word-btn.selected {
  animation: pop 0.3s ease;
}

/* Fade-out transition when a word is selected */
.start-overlay.selection-made h1,
.start-overlay.selection-made .word-option:not(.selected) {
  opacity: 0;
  transition: opacity 0.3s;
}

.start-overlay.selection-made .word-option.selected .word-btn {
  background: transparent;
  box-shadow: none;
}
```

#### `game/js/audio.mjs`
Web Audio helpers for playing letters, words, and sound effects with caching.

```
// Play letter pronunciations using the Web Audio API. Letter clips are
// decoded into an AudioBuffer and a fresh AudioBufferSourceNode is
// created for each playback so repeated letters work reliably across
// browsers, including iOS.

// Lazy-create the audio context so it's only built after a user gesture.
let ctx;
function audioCtx() {
  return ctx ??= new (window.AudioContext || window.webkitAudioContext)();
}

/* ---- 1. unlock on any gesture Safari/WebView understands ---- */
['pointerdown', 'touchstart', 'click'].forEach(type =>
  window.addEventListener(type, () => audioCtx().resume(), { once: true })
);

/* ---- 2. helper that guarantees the context is running ---- */
export async function ensureRunning() {
  const c = audioCtx();
  if (c.state !== 'running') await c.resume(); // await is vital
}

/* ---- 3. play audio clips ---- */
const cache = {};

export async function playLetter(letter) {
  await ensureRunning(); // must finish before start()
  const upper = letter.toUpperCase();
  let buf = cache[upper];
  if (!buf) {
    const url = new URL(
      `../../assets/audio/alphabet/FR/${upper}.mp3`,
      import.meta.url
    );
    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const bytes = await res.arrayBuffer();
    buf = cache[upper] = await audioCtx().decodeAudioData(bytes);
  }
  const src = audioCtx().createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx().destination);
  src.start();
}

export async function playWord(word) {
  await ensureRunning();
  const upper = word.toUpperCase();
  const file = upper.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  const key = `WORD:${file}`;
  let buf = cache[key];
  if (!buf) {
    const url = new URL(
      `../../assets/audio/words/FR/${file}.mp3`,
      import.meta.url
    );
    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const bytes = await res.arrayBuffer();
    buf = cache[key] = await audioCtx().decodeAudioData(bytes);
  }
  const src = audioCtx().createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx().destination);
  src.start();
  return new Promise((res) => src.addEventListener('ended', res, { once: true }));
}

export async function playSuccess() {
  await ensureRunning();
  const key = 'SFX:SUCCESS';
  let buf = cache[key];
  if (!buf) {
    const url = new URL(
      '../../assets/audio/SFX/SUCCESS.mp3',
      import.meta.url
    );
    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const bytes = await res.arrayBuffer();
    buf = cache[key] = await audioCtx().decodeAudioData(bytes);
  }
  const src = audioCtx().createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx().destination);
  src.start();
  return new Promise((res) => src.addEventListener('ended', res, { once: true }));
}

export async function playBravo() {
  await ensureRunning();
  const key = 'SFX:BRAVO';
  let buf = cache[key];
  if (!buf) {
    const url = new URL(
      '../../assets/audio/SFX/BRAVO.mp3',
      import.meta.url
    );
    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const bytes = await res.arrayBuffer();
    buf = cache[key] = await audioCtx().decodeAudioData(bytes);
  }
  const src = audioCtx().createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx().destination);
  src.start();
  return new Promise((res) => src.addEventListener('ended', res, { once: true }));
}

const bubbleHistory = [];

export async function playBubble() {
  await ensureRunning();
  const indices = [0, 1, 2, 3, 4];
  const available = indices.filter((i) => !bubbleHistory.includes(i));
  const idx = available[Math.floor(Math.random() * available.length)];
  const key = `SFX:BUBBLE_${idx}`;
  let buf = cache[key];
  if (!buf) {
    const url = new URL(
      `../../assets/audio/SFX/bubbles/bubble_0${idx + 1}.mp3`,
      import.meta.url
    );
    const res = await fetch(url, { mode: 'cors' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    const bytes = await res.arrayBuffer();
    buf = cache[key] = await audioCtx().decodeAudioData(bytes);
  }
  const src = audioCtx().createBufferSource();
  src.buffer = buf;
  src.connect(audioCtx().destination);
  src.start();
  bubbleHistory.push(idx);
  if (bubbleHistory.length > 2) bubbleHistory.shift();
}

// This module intentionally only exposes the letter, word, bubble, success, and bravo audio.
```

#### `game/js/drag-drop.mjs`
Pointer-friendly drag-and-drop interactions for letter tiles and slots.

```
import { playLetter } from './audio.mjs';

export function setupDragDrop(slots, tiles, onComplete) {
  const isComplete = () => slots.every((s) => s.classList.contains('filled'));
  let current;
  let outerTarget;
  let activeTile = null;
  let startX, startY;

  const startEvents = window.PointerEvent
    ? ['pointerdown']
    : ['mousedown', 'touchstart'];
  const moveEvents = window.PointerEvent
    ? ['pointermove']
    : ['mousemove', 'touchmove'];
  const endEvents = window.PointerEvent
    ? ['pointerup', 'pointercancel']
    : ['mouseup', 'touchend', 'touchcancel'];

  const getPoint = (e) =>
    e.touches?.[0] || e.changedTouches?.[0] || e;

  const intersectingSlot = (tile) => {
    const t = tile.getBoundingClientRect();
    return slots.find((slot) => {
      if (slot.classList.contains('filled')) return false;
      const r = slot.getBoundingClientRect();
      const expandedTop = r.top - r.height * 0.25;
      const expandedBottom = r.bottom + r.height * 0.25;
      return (
        t.right > r.left &&
        t.left < r.right &&
        t.bottom > expandedTop &&
        t.top < expandedBottom
      );
    });
  };

  const inOuterHitbox = (tile, slot) => {
    const t = tile.getBoundingClientRect();
    const r = slot.getBoundingClientRect();
    const marginX = r.width * 0.15; // 30% larger overall
    const marginY = r.height * 0.15;
    return (
      t.right > r.left - marginX &&
      t.left < r.right + marginX &&
      t.bottom > r.top - marginY &&
      t.top < r.bottom + marginY
    );
  };

  const move = (e) => {
    if (!activeTile) return;
    const p = getPoint(e);
    const dx = p.clientX - startX;
    const dy = p.clientY - startY;
    activeTile.style.transform = `translate(${dx}px, ${dy}px) scale(1.1)`;

    const over = intersectingSlot(activeTile);
    if (over !== current) {
      if (current) {
        current.classList.remove('hover');
        outerTarget = current; // activate outer hitbox for previous slot
      }
      if (over && !over.classList.contains('filled')) {
        over.classList.add('hover');
        outerTarget = null; // inner hover takes priority
      }
      current = over;
    }
  };

  const clearHover = () => {
    if (current) {
      current.classList.remove('hover');
      outerTarget = current;
      current = null;
    }
  };

  const end = (e) => {
    if (!activeTile) return;
    moveEvents.forEach((ev) => document.removeEventListener(ev, move));
    endEvents.forEach((ev) => document.removeEventListener(ev, end));
    // Ensure the tile position reflects the final pointer location.
    // Fast drags may not fire a last pointermove, so manually update
    // using the pointerup coordinates before evaluating the drop.
    move(e);
    const tile = activeTile;
    activeTile = null;
    let dropSlot = intersectingSlot(tile);
    if (!dropSlot && outerTarget && !outerTarget.classList.contains('filled') && inOuterHitbox(tile, outerTarget)) {
      dropSlot = outerTarget;
    }
    tile.style.transition = 'transform 0.2s';
    tile.style.transform = '';
    clearHover();
    outerTarget = null;
    let wrongDrop = false;
    if (dropSlot && !dropSlot.classList.contains('filled')) {
      const letter = tile.textContent;
      if (letter === dropSlot.dataset.letter) {
        dropSlot.textContent = letter;
        dropSlot.classList.add('filled', 'placed');
        dropSlot.classList.remove('preview');
        tile.used = true;
        tile.style.visibility = 'hidden';
        // Announce the locked-in letter immediately upon correct placement.
        playLetter(letter);
        dropSlot.addEventListener('animationend', () => dropSlot.classList.remove('placed'), { once: true });
        if (isComplete()) {
          onComplete();
        }
      } else {
        wrongDrop = true;
        dropSlot.classList.add('wrong', 'flash-letter');
        dropSlot.addEventListener('animationend', () => {
          dropSlot.classList.remove('wrong');
          dropSlot.classList.remove('flash-letter');
        }, { once: true });
        tile.addEventListener('animationend', () => tile.classList.remove('shake'), { once: true });
      }
    }
    tile.addEventListener('transitionend', () => {
      tile.style.transition = '';
      if (wrongDrop) {
        tile.classList.add('shake');
      }
    }, { once: true });
    tile.classList.remove('active');
  };

  const startDrag = (tile, e) => {
    if (tile.used || activeTile) return;
    activeTile = tile;
    const p = getPoint(e);
    startX = p.clientX;
    startY = p.clientY;
    outerTarget = null;
    tile.classList.add('active');
    if (e.pointerId !== undefined && tile.setPointerCapture) {
      tile.setPointerCapture(e.pointerId);
    }
    moveEvents.forEach((ev) => document.addEventListener(ev, move, { passive: false }));
    endEvents.forEach((ev) => document.addEventListener(ev, end));
  };

  tiles.forEach((tile) => {
    tile.draggable = false;
    tile.style.touchAction = 'none';
    startEvents.forEach((type) => {
      tile.addEventListener(
        type,
        (e) => {
          e.stopPropagation();
          e.preventDefault();
          startDrag(tile, e);
        },
        { passive: false }
      );
    });
  });

  const container = document.getElementById('tiles');
  startEvents.forEach((type) => {
    container.addEventListener(
      type,
      (e) => {
        if (e.target.classList.contains('tile')) return;
        const p = getPoint(e);
        const x = p.clientX;
        const y = p.clientY;
        let candidate = null;
        let bestDist = Infinity;
        tiles.forEach((tile) => {
          if (tile.used) return;
          const r = tile.getBoundingClientRect();
          const marginX = r.width * 0.25; // expand width 50%
          const marginY = r.height * 0.25;
          if (
            x >= r.left - marginX &&
            x <= r.right + marginX &&
            y >= r.top - marginY &&
            y <= r.bottom + marginY
          ) {
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const dist = Math.hypot(x - cx, y - cy);
            if (dist < bestDist) {
              bestDist = dist;
              candidate = tile;
            }
          }
        });
        if (candidate) {
          startDrag(candidate, e);
        }
      },
      { passive: false }
    );
  });
}
```

#### `game/js/main.mjs`
Gameplay loop coordinating word selection, animations, history, and celebration.

```
import { setupDragDrop } from './drag-drop.mjs';
import { allSlotsFilled } from './word-check.mjs';
import { startConfetti as createConfettiEffect } from '../../js/confetti.js';
import { ensureRunning, playWord, playSuccess, playBubble } from './audio.mjs';

let stopConfettiEffect;
let bounceCount = 0;
let bounceHandler;
let currentTiles = [];
function parseLimit(value) {
  if (!value) return 30;
  return value === 'inf' ? Infinity : parseInt(value, 10);
}

let sessionLimit = parseLimit(sessionStorage.getItem('wordLimit'));
let wordsPlayed = 0;
const previewMode = localStorage.getItem('previewMode') || 'full';

function updateScale() {
  const layout = document.querySelector('.game-layout');
  if (!layout) return;
  const width = layout.offsetWidth;
  const height = layout.offsetHeight;
  const scale = Math.min(window.innerWidth / width, window.innerHeight / height, 1);
  layout.style.transform = `scale(${scale})`;
}

function findOffset(base, placed, tileW, tileH, maxX, maxY) {
  const area = tileW * tileH;
  let best = { x: 0, y: 0, overlap: Infinity };
  for (let i = 0; i < 20; i++) {
    const ox = (Math.random() * 2 - 1) * maxX;
    const oy = (Math.random() * 2 - 1) * maxY;
    const rect = { x: base.x + ox, y: base.y + oy };
    let worst = 0;
    for (const p of placed) {
      const ow = Math.max(0, Math.min(rect.x + tileW, p.x + tileW) - Math.max(rect.x, p.x));
      const oh = Math.max(0, Math.min(rect.y + tileH, p.y + tileH) - Math.max(rect.y, p.y));
      worst = Math.max(worst, ow * oh);
      if (worst > area * 0.2) break;
    }
    if (worst <= area * 0.2) {
      return { offsetX: ox, offsetY: oy };
    }
    if (worst < best.overlap) {
      best = { x: ox, y: oy, overlap: worst };
    }
  }
  return { offsetX: best.x, offsetY: best.y };
}

function layoutTiles(tiles) {
  const container = document.getElementById('tiles');
  if (!container || tiles.length === 0) return;
  const width = container.offsetWidth;
  const sampleSlot = document.querySelector('.slot');
  const tileW = sampleSlot ? sampleSlot.offsetWidth : 40;
  const tileH = sampleSlot ? sampleSlot.offsetHeight : 50;
  let cols = Math.min(tiles.length, Math.max(1, Math.floor(width / tileW)));
  let spacingX = (width - cols * tileW) / (cols + 1);
  while (cols > 1 && spacingX < tileW * 0.25) {
    cols--;
    spacingX = (width - cols * tileW) / (cols + 1);
  }
  spacingX = Math.max(spacingX, tileW * 0.25);
  const spacingY = tileH * 0.25;
  const rows = Math.ceil(tiles.length / cols);
  const neededHeight = rows * tileH + (rows + 1) * spacingY;
  container.style.height = `${neededHeight}px`;
  const positions = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols && positions.length < tiles.length; c++) {
      positions.push({
        x: spacingX + c * (tileW + spacingX),
        y: spacingY + r * (tileH + spacingY),
      });
    }
  }
  shuffle(positions);
  const placed = [];
  const maxOffsetX = Math.min(spacingX * 0.8, tileW * 0.4);
  const maxOffsetY = Math.min(spacingY * 0.8, tileH * 0.3);
  tiles.forEach((tile, idx) => {
    const pos = positions[idx];
    let offsetX = parseFloat(tile.dataset.offsetX);
    let offsetY = parseFloat(tile.dataset.offsetY);
    if (isNaN(offsetX) || isNaN(offsetY)) {
      ({ offsetX, offsetY } = findOffset(pos, placed, tileW, tileH, maxOffsetX, maxOffsetY));
      tile.dataset.offsetX = offsetX;
      tile.dataset.offsetY = offsetY;
    }
    const finalX = pos.x + offsetX;
    const finalY = pos.y + offsetY;
    tile.style.left = `${finalX}px`;
    tile.style.top = `${finalY}px`;
    placed.push({ x: finalX, y: finalY });
  });
}

function repositionTiles() {
  const active = currentTiles.filter((t) => !t.used);
  layoutTiles(active);
}

function handleResize() {
  repositionTiles();
  updateScale();
}

// Emoji history management
let wordHistory = [];

function loadHistory() {
  const stored = sessionStorage.getItem('wordHistory');
  wordHistory = stored ? JSON.parse(stored) : [];
}

function saveHistory() {
  sessionStorage.setItem('wordHistory', JSON.stringify(wordHistory));
}

function renderHistory() {
  const container = document.getElementById('history');
  if (!container) return;
  container.innerHTML = '';
  const limit = sessionLimit === Infinity ? wordHistory.length : sessionLimit;
  for (let i = 0; i < limit; i++) {
    const span = document.createElement('span');
    if (i < wordHistory.length) {
      span.className = 'history-emoji';
      span.textContent = wordHistory[i];
    } else {
      span.className = 'history-placeholder';
      span.textContent = '';
    }
    container.appendChild(span);
  }
}

function addToHistory(emoji) {
  wordHistory.push(emoji);
  if (wordHistory.length > 30) {
    wordHistory = wordHistory.slice(-30);
  }
  saveHistory();
  renderHistory();
}

async function loadWords() {
  // When the game is loaded from /game/index.html, the words JSON
  // lives in the sibling "data" directory. The previous relative
  // path used "../data" which incorrectly pointed one level above
  // the game folder, resulting in a 404 and an empty screen. Use the
  // correct relative path so the word list loads properly.
  const res = await fetch('data/words-fr.json');
  return res.json();
}

// Word playlist management
let wordList = [];
let playlist = [];
let playlistIndex = 0;
let previousWord = null;

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function nextWord() {
  if (playlist.length === 0 || playlistIndex >= playlist.length) {
    playlist = [...wordList];
    shuffle(playlist);
    if (previousWord && playlist.length > 1) {
      // ensure the previously played word only appears after all others
      const prevIdx = playlist.findIndex((w) => w.word === previousWord.word);
      if (prevIdx !== -1) {
        const [prev] = playlist.splice(prevIdx, 1);
        playlist.push(prev);
      }
    }
    playlistIndex = 0;
  }
  const wordObj = playlist[playlistIndex];
  playlistIndex++;
  previousWord = wordObj;
  return wordObj;
}


function createSlots(word) {
  const container = document.getElementById('word');
  container.innerHTML = '';
  const slots = [];
  let previewIndices = [];
  if (previewMode === 'full') {
    previewIndices = [...word].map((_, idx) => idx);
  } else if (previewMode === 'partial') {
    previewIndices = [...word].map((_, idx) => idx);
    shuffle(previewIndices);
    previewIndices = previewIndices.slice(0, Math.ceil(word.length / 2));
  }
  for (const [idx, letter] of [...word].entries()) {
    const d = document.createElement('div');
    d.className = 'slot preview';
    d.dataset.letter = letter;
    d.textContent = previewIndices.includes(idx) ? letter : '?';
    container.appendChild(d);
    slots.push(d);
  }
  return slots;
}

function createTiles(word) {
  const container = document.getElementById('tiles');
  container.innerHTML = '';
  const letters = word.split('');
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  while (letters.length < word.length + 5) {
    letters.push(alphabet[Math.floor(Math.random() * alphabet.length)]);
  }
  // simple shuffle
  for (let i = letters.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [letters[i], letters[j]] = [letters[j], letters[i]];
  }
  const tiles = [];
  for (const letter of letters) {
    const d = document.createElement('div');
    d.className = 'tile';
    d.textContent = letter;
    container.appendChild(d);
    tiles.push(d);
  }
  layoutTiles(tiles);
  tiles.forEach((d) => {
    d.style.opacity = 0;
    d.style.transform = 'scale(0)';
  });
  return tiles;
}

function animateTilesIn(tiles) {
  const order = [...tiles];
  shuffle(order);
  order.forEach((tile, idx) => {
    const delay = idx * 150;
    const anim = tile.animate(
      [
        { transform: 'scale(0)', opacity: 0 },
        { transform: 'scale(1.2)', opacity: 1 },
        { transform: 'scale(1)', opacity: 1 }
      ],
      { duration: 300, easing: 'ease-out', delay }
    );
    setTimeout(() => playBubble(), delay);
    anim.addEventListener('finish', () => {
      tile.style.opacity = 1;
      tile.style.transform = '';
      anim.cancel();
    });
  });
}

function startConfetti() {
  stopConfettiEffect = createConfettiEffect();
}

function stopConfetti() {
  if (stopConfettiEffect) {
    stopConfettiEffect();
    stopConfettiEffect = null;
  }
}

function startPictureAnimation() {
  const pic = document.getElementById('picture');
  bounceCount = 0;
  pic.classList.add('animate');
  bounceHandler = () => {
    bounceCount++;
    if (bounceCount % 10 === 0) {
      pic.animate([
        { transform: 'scale(1.3) rotate(0deg)' },
        { transform: 'scale(1.3) rotate(360deg)' }
      ], { duration: 400 });
    }
  };
  pic.addEventListener('animationiteration', bounceHandler);
}

function stopPictureAnimation() {
  const pic = document.getElementById('picture');
  pic.classList.remove('animate');
  if (bounceHandler) {
    pic.removeEventListener('animationiteration', bounceHandler);
    bounceHandler = null;
  }
}

function createBravoMessage() {
  const gradient = ['#FFA500', '#FF8A00', '#FF6F00', '#FF5400', '#FF3800', '#FF0000'];
  const text = 'BRAVO !';
  let colorIdx = 0;
  return text
    .split('')
    .map(ch => {
      if (ch === ' ') {
        return ' ';
      }
      const color = gradient[colorIdx++];
      return `<span style="color:${color}">${ch}</span>`;
    })
    .join('');
}

function celebrate() {
  const msg = document.getElementById('message');
  msg.innerHTML = createBravoMessage();
  msg.classList.add('show');
  startConfetti();
  startPictureAnimation();
  setTimeout(dropUnusedTiles, 400);
}

function dropUnusedTiles() {
  currentTiles.forEach((tile) => {
    if (tile.used) return;
    tile.classList.add('drop');
    tile.style.setProperty('--spin', `${Math.random() * 60 - 30}deg`);
    tile.style.setProperty('--duration', `${1.5 + Math.random()}s`);
    tile.style.setProperty('--delay', `${Math.random() * 0.5}s`);
    tile.addEventListener('animationend', () => tile.remove(), { once: true });
  });
}

function endGame() {
  // give the player a brief moment to enjoy the final word animation
  setTimeout(() => {
    document.body.classList.add('fade-out');
    setTimeout(() => {
      window.location.href = '../celebration/';
    }, 500);
  }, 1800);
}

async function animateWordReveal(slots) {
  const duration = 300;
  const delay = 200;
  const wordEl = document.getElementById('word');

  const animations = slots.map((slot, idx) =>
    slot
      .animate(
        [
          { transform: 'scale(1)' },
          { transform: 'scale(1.3)' },
          { transform: 'scale(1)' },
        ],
        { duration, easing: 'ease', delay: idx * delay }
      )
      .finished
  );
  await Promise.all(animations);

  const word = slots.map((s) => s.textContent).join('');
  const wordAnim = wordEl.animate(
    [
      { transform: 'scale(1)' },
      { transform: 'scale(1.3)' },
      { transform: 'scale(1)' },
    ],
    { duration, easing: 'ease' }
  );
  await Promise.all([playWord(word), wordAnim.finished]);
}

function showWord(wordObj, animateTiles = true) {
  const pic = document.getElementById('picture');
  pic.textContent = wordObj.emoji;
  pic.onpointerdown = () => {
    pic.animate(
      [
        { transform: 'scale(1)' },
        { transform: 'scale(1.3)' },
        { transform: 'scale(1)' },
      ],
      { duration: 300, easing: 'ease' }
    );
    playWord(wordObj.word);
  };
  const slots = createSlots(wordObj.word);
  const tiles = createTiles(wordObj.word);
  currentTiles = tiles;
  document.fonts.ready.then(handleResize);
  const nextBtn = document.getElementById('next');
  nextBtn.style.display = 'none';
  document.getElementById('message').classList.remove('show');
  stopConfetti();
  stopPictureAnimation();
  setupDragDrop(slots, tiles, () => {
      if (allSlotsFilled(slots)) {
        animateWordReveal(slots).then(() => {
          playSuccess();
          celebrate();
          addToHistory(wordObj.emoji);
          wordsPlayed++;
          if (sessionLimit !== Infinity && wordsPlayed >= sessionLimit) {
            endGame();
          } else {
            nextBtn.style.display = 'inline-block';
          }
        });
      }
    });
  nextBtn.textContent = 'Mot suivant \u27A1\uFE0F';
  nextBtn.onclick = () => {
    document.body.classList.add('word-fade-out');
    setTimeout(() => {
      document.body.classList.remove('word-fade-out');
      startGame();
      document.body.classList.add('word-fade-in');
      setTimeout(() => document.body.classList.remove('word-fade-in'), 200);
    }, 200);
  };
  if (animateTiles) {
    requestAnimationFrame(() => animateTilesIn(tiles));
  } else if (wordsPlayed > 0) {
    // When switching to the next word we skip the entrance animation to
    // avoid delay, but the tiles still need to be visible. Explicitly reset
    // the styles that `createTiles` uses to hide them so they appear
    // immediately.
    tiles.forEach((tile) => {
      tile.style.opacity = 1;
      tile.style.transform = '';
    });
  }
}

async function startGame() {
  if (wordList.length === 0) {
    wordList = await loadWords();
  }
  const word = nextWord();
  showWord(word, wordsPlayed === 0);
}

function openSettings() {
  document.getElementById('settings-modal').classList.remove('hidden');
}

function closeSettings() {
  document.getElementById('settings-modal').classList.add('hidden');
}

async function handleFirstSelection(wordObj, btn) {
  btn.classList.add('selected');
  btn.parentElement.classList.add('selected');
  const overlay = document.getElementById('start-overlay');
  const startRect = btn.getBoundingClientRect();

  await ensureRunning();
  showWord(wordObj, false);
  previousWord = wordObj;

  // Hide game elements until transition completes
  const revealEls = [
    document.getElementById('picture'),
    document.getElementById('word'),
    document.getElementById('tiles'),
    document.getElementById('settings-btn'),
    document.getElementById('message'),
    document.getElementById('history'),
    document.getElementById('next'),
  ];
  revealEls.forEach((el) => {
    if (el) el.style.opacity = 0;
  });

  // Fade out other choices and title
  overlay.classList.add('selection-made');
  await new Promise((res) => setTimeout(res, 300));

  const picture = document.getElementById('picture');
  const endRect = picture.getBoundingClientRect();

  // Create flying emoji at original position
  const fly = document.createElement('span');
  fly.textContent = wordObj.emoji;
  fly.style.position = 'fixed';
  fly.style.left = `${startRect.left + startRect.width / 2}px`;
  fly.style.top = `${startRect.top + startRect.height / 2}px`;
  fly.style.transform = 'translate(-50%, -50%)';
  fly.style.fontSize = window.getComputedStyle(picture).fontSize;
  fly.style.zIndex = '10';
  document.body.appendChild(fly);
  btn.style.visibility = 'hidden';

  await fly
    .animate(
      [
        {
          left: `${startRect.left + startRect.width / 2}px`,
          top: `${startRect.top + startRect.height / 2}px`,
        },
        {
          left: `${endRect.left + endRect.width / 2}px`,
          top: `${endRect.top + endRect.height / 2}px`,
        },
      ],
      { duration: 300, easing: 'ease-in-out', fill: 'forwards' }
    )
    .finished;
  await new Promise((res) => setTimeout(res, 400));
  overlay.classList.add('hidden');

  // Reveal game elements
  revealEls.forEach((el) => {
    if (el) {
      el.style.transition = 'opacity 0.7s';
      el.style.opacity = 1;
    }
  });
  await new Promise((res) => setTimeout(res, 700));
  document.body.removeChild(fly);
  animateTilesIn(currentTiles);
}

function renderFirstWordOptions() {
  const container = document.getElementById('word-choices');
  if (!container) return;
  container.innerHTML = '';
  const shuffled = [...wordList];
  shuffle(shuffled);
  const options = shuffled.slice(0, 4);
  options.forEach((wordObj) => {
    const option = document.createElement('div');
    option.className = 'word-option';
    const btn = document.createElement('button');
    btn.className = 'word-btn';
    btn.textContent = wordObj.emoji;
    btn.addEventListener('click', () => handleFirstSelection(wordObj, btn));
    option.appendChild(btn);
    container.appendChild(option);
  });
}

window.addEventListener('DOMContentLoaded', async () => {
  wordsPlayed = 0;
  sessionLimit = parseLimit(sessionStorage.getItem('wordLimit'));
  loadHistory();
  renderHistory();
  handleResize();
  document.fonts.ready.then(handleResize);

  wordList = await loadWords();
  const lengthSetting = localStorage.getItem('wordLength') || 'mixed';
  if (lengthSetting === 'short') {
    wordList = wordList.filter((w) => w.word.length <= 5);
  } else if (lengthSetting === 'long') {
    wordList = wordList.filter((w) => w.word.length >= 6);
  }
  renderFirstWordOptions();

  const settingsBtn = document.getElementById('settings-btn');
  const continueBtn = document.getElementById('continue-btn');
  const skipBtn = document.getElementById('skip-btn');
  const menuBtn = document.getElementById('menu-btn');
  const settingsModal = document.getElementById('settings-modal');

  settingsBtn.addEventListener('click', openSettings);
  continueBtn.addEventListener('click', closeSettings);
  settingsModal.addEventListener('click', (e) => {
    if (e.target === settingsModal) {
      closeSettings();
    }
  });
  skipBtn.addEventListener('click', () => {
    closeSettings();
    startGame();
  });
  menuBtn.addEventListener('click', () => {
    sessionStorage.removeItem('wordHistory');
    window.location.href = '../';
  });
  window.addEventListener('resize', handleResize);
  window.addEventListener('orientationchange', handleResize);
});
```

#### `game/js/word-check.mjs`
Utility to verify whether all letter slots are filled.

```
export function allSlotsFilled(slots) {
  return slots.every((s) => s.classList.contains('filled'));
}
```

#### `game/data/words-fr.json`
Emoji-enhanced French word list consumed by the game.

```

[
  {"emoji": "üêù", "word": "ABEILLE"},
  {"emoji": "üçç", "word": "ANANAS"},
  {"emoji": "üå≥", "word": "ARBRE"},
  {"emoji": "‚úàÔ∏è", "word": "AVION"},
  {"emoji": "üéà", "word": "BALLON"},
  {"emoji": "üçå", "word": "BANANE"},
  {"emoji": "üö¢", "word": "BATEAU"},
  {"emoji": "üçº", "word": "BIBERON"},
  {"emoji": "üç™", "word": "BISCUIT"},
  {"emoji": "üç¨", "word": "BONBON"},
  {"emoji": "üïØÔ∏è", "word": "BOUGIE"},
  {"emoji": "ü•¶", "word": "BROCOLI"},
  {"emoji": "‚òï", "word": "CAFE"},
  {"emoji": "üöö", "word": "CAMION"},
  {"emoji": "ü•ï", "word": "CAROTTE"},
  {"emoji": "üîí", "word": "CADENAS"},
  {"emoji": "ü¶å", "word": "CERF"},
  {"emoji": "üçí", "word": "CERISE"},
  {"emoji": "üçÑ", "word": "CHAMPI"},
  {"emoji": "ü™ë", "word": "CHAISE"},
  {"emoji": "üê±", "word": "CHAT"},
  {"emoji": "üê∂", "word": "CHIEN"},
  {"emoji": "üêé", "word": "CHEVAL"},
  {"emoji": "ü•¨", "word": "CHOU"},
  {"emoji": "5Ô∏è‚É£", "word": "CINQ"},
  {"emoji": "‚ù§Ô∏è", "word": "COEUR"},
  {"emoji": "üïäÔ∏è", "word": "COLOMBE"},
  {"emoji": "‚òÑÔ∏è", "word": "COMETE"},
  {"emoji": "‚úèÔ∏è", "word": "CRAYON"},
  {"emoji": "üê¨", "word": "DAUPHIN"},
  {"emoji": "2Ô∏è‚É£", "word": "DEUX"},
  {"emoji": "ü¶É", "word": "DINDE"},
  {"emoji": "üêâ", "word": "DRAGON"},
  {"emoji": "üîü", "word": "DIX"},
  {"emoji": "üíß", "word": "EAU"},
  {"emoji": "üè´", "word": "ECOLE"},
  {"emoji": "‚≠ê", "word": "ETOILE"},
  {"emoji": "üå∏", "word": "FLEUR"},
  {"emoji": "üçÉ", "word": "FEUILLE"},
  {"emoji": "üßÄ", "word": "FROMAGE"},
  {"emoji": "üçì", "word": "FRAISE"},
  {"emoji": "üç¶", "word": "GLACE"},
  {"emoji": "üé∏", "word": "GUITARE"},
  {"emoji": "üêπ", "word": "HAMSTER"},
  {"emoji": "üöÅ", "word": "HELICO"},
  {"emoji": "ü¶â", "word": "HIBOU"},
  {"emoji": "8Ô∏è‚É£", "word": "HUIT"},
  {"emoji": "üèùÔ∏è", "word": "ILE"},
  {"emoji": "üß∏", "word": "JOUET"},
  {"emoji": "ü•ù", "word": "KIWI"},
  {"emoji": "ü¶ô", "word": "LAMA"},
  {"emoji": "üê∞", "word": "LAPIN"},
  {"emoji": "üêÜ", "word": "L√âOPARD"},
  {"emoji": "ü¶Ñ", "word": "LICORNE"},
  {"emoji": "ü¶Å", "word": "LION"},
  {"emoji": "üìñ", "word": "LIVRE"},
  {"emoji": "ü•õ", "word": "LAIT"},
  {"emoji": "üåΩ", "word": "MAIS"},
  {"emoji": "üè†", "word": "MAISON"},
  {"emoji": "ü•≠", "word": "MANGUE"},
  {"emoji": "üçà", "word": "MELON"},
  {"emoji": "üöá", "word": "METRO"},
  {"emoji": "üèçÔ∏è", "word": "MOTO"},
  {"emoji": "üêë", "word": "MOUTON"},
  {"emoji": "‚ùÑÔ∏è", "word": "NEIGE"},
  {"emoji": "üê¶", "word": "OISEAU"},
  {"emoji": "üëÅÔ∏è", "word": "OEIL"},
  {"emoji": "üç≥", "word": "OEUF"},
  {"emoji": "üçû", "word": "PAIN"},
  {"emoji": "üèñÔ∏è", "word": "PLAGE"},
  {"emoji": "üçê", "word": "POIRE"},
  {"emoji": "üçï", "word": "PIZZA"},
  {"emoji": "üçé", "word": "POMME"},
  {"emoji": "üêî", "word": "POULE"},
  {"emoji": "üê•", "word": "POUSSIN"},
  {"emoji": "üß©", "word": "PUZZLE"},
  {"emoji": "4Ô∏è‚É£", "word": "QUATRE"},
  {"emoji": "üêÄ", "word": "RAT"},
  {"emoji": "ü¶ä", "word": "RENARD"},
  {"emoji": "ü¶à", "word": "REQUIN"},
  {"emoji": "üåπ", "word": "ROSE"},
  {"emoji": "ü•ó", "word": "SALADE"},
  {"emoji": "üõ¥", "word": "SCOOTER"},
  {"emoji": "üéÑ", "word": "SAPIN"},
  {"emoji": "7Ô∏è‚É£", "word": "SEPT"},
  {"emoji": "6Ô∏è‚É£", "word": "SIX"},
  {"emoji": "‚òÄÔ∏è", "word": "SOLEIL"},
  {"emoji": "üê≠", "word": "SOURIS"},
  {"emoji": "üöï", "word": "TAXI"},
  {"emoji": "ü•Å", "word": "TAMBOUR"},
  {"emoji": "üöÜ", "word": "TRAIN"},
  {"emoji": "üöä", "word": "TRAM"},
  {"emoji": "üêÖ", "word": "TIGRE"},
  {"emoji": "üçÖ", "word": "TOMATE"},
  {"emoji": "üê¢", "word": "TORTUE"},
  {"emoji": "1Ô∏è‚É£", "word": "UN"},
  {"emoji": "üö≤", "word": "VELO"},
  {"emoji": "‚õµ", "word": "VOILIER"},
  {"emoji": "ü¶ì", "word": "ZEBRE"}
]

```

#### `celebration/index.html`
Celebration page with rotating emoji wheel and navigation back to menu.

```
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bravo !</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/base.css">
  <link rel="stylesheet" href="css/celebration.css">
</head>
<body>
  <h1 class="title titan-one-regular" aria-label="BRAVO !">
    <span style="--i:0">B</span><span style="--i:1">R</span><span style="--i:2">A</span><span style="--i:3">V</span><span style="--i:4">O</span><span style="--i:5">&#160;!</span>
  </h1>
  <div id="wheel">
    <span id="thumb-up" aria-hidden="true">üëç</span>
    <div id="emoji-container" class="emojis"></div>
  </div>
  <button id="menu" class="btn play">Menu principal ‚Ü©Ô∏è</button>
  <script type="module" src="js/celebration.js"></script>
  <script src="../sw-register.js"></script>
</body>
</html>
```

#### `celebration/css/celebration.css`
Festive gradients, spinning emojis, and button reveal animations.

```
body {
  text-align: center;
  padding-top: 3rem;
  background: linear-gradient(-45deg, #fff8e1, #ffccbc, #ff8a65, #f48fb1);
  background-size: 400% 400%;
  animation: fade-in 0.6s ease-out forwards, gradient-bg 12s ease infinite;
  opacity: 0;
  overflow: hidden;
  height: 100vh;
}

@keyframes gradient-bg {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.title {
  font-size: clamp(3rem, 10vw, 5rem);
  margin-bottom: 1rem;
}

.title span {
  display: inline-block;
  animation: rainbow 3s linear infinite;
  animation-delay: calc(var(--i) * 0.2s);
}

@keyframes rainbow {
  0% { color: #ff6b6b; }
  25% { color: #fcbf49; }
  50% { color: #4caf50; }
  75% { color: #2196f3; }
  100% { color: #ff6b6b; }
}

.emojis {
  position: relative;
  width: 80vmin;
  height: 80vmin;
  margin: 0 auto;
  animation: rotateCircle 10s linear infinite;
}

#wheel {
  width: 80vmin;
  height: 80vmin;
  margin: 2rem auto;
  animation: wheelPulse 4s ease-in-out infinite;
  position: relative;
}

#thumb-up {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-size: clamp(4rem, 20vmin, 8rem);
  animation: pulse 1.6s ease-in-out infinite;
  z-index: 1;
  pointer-events: auto;
  cursor: pointer;
}

.trophy {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  font-size: clamp(3rem, 10vmin, 5rem);
  will-change: transform;
}

@keyframes wheelPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(0.85); }
}

@keyframes rotateCircle {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.emoji-wrapper {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: rotate(var(--angle)) translate(var(--radius)) rotate(calc(-1 * var(--angle)));
}

.emoji {
  display: block;
  transform-origin: center;
}

.emoji.spin {
  animation: emojiSpin 0.6s ease-in-out;
}

@keyframes emojiSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.3); }
}

/* button styles moved to base.css */

#menu {
  font-size: clamp(1.2rem, 3vw, 1.6rem);
  margin-top: 2rem;
  opacity: 0;
  animation: menuFadeIn 0.6s ease-out forwards;
  animation-delay: 2s;
}

@keyframes menuFadeIn {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
```

#### `celebration/js/celebration.js`
Runs confetti, trophy bursts, and audio feedback on celebration screen.

```
// Use the shared confetti script from the project root.
import { startConfetti } from '../../js/confetti.js';
import { playBravo, playBubble } from '../../game/js/audio.mjs';

window.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('emoji-container');
  const menuBtn = document.getElementById('menu');
  const thumbUp = document.getElementById('thumb-up');
  const wheel = document.getElementById('wheel');
  const stored = sessionStorage.getItem('wordHistory');
  const emojis = stored ? JSON.parse(stored) : [];

  const stopConfetti = startConfetti();

  // Attempt to play the celebration audio immediately; if the browser
  // blocks autoplay (e.g. due to missing user interaction), retry after
  // the first pointer/touch/click event.
  playBravo().catch(() => {
    const retry = () => {
      playBravo();
      ['pointerdown', 'touchstart', 'click'].forEach((t) =>
        window.removeEventListener(t, retry)
      );
    };
    ['pointerdown', 'touchstart', 'click'].forEach((t) =>
      window.addEventListener(t, retry, { once: true })
    );
  });

  const wrappers = [];
  const trophies = new Set();
  const GRAVITY = 800; // px/s^2
  let lastTime = null;

  function spawnTrophy() {
    const trophy = document.createElement('span');
    trophy.textContent = 'üèÜ';
    trophy.className = 'trophy';
    trophy.x = 0;
    trophy.y = 0;
    const angle =
      Math.PI * 1.5 + // center straight up (screen coords)
      (Math.random() - 0.5) * Math.PI * 0.5; // spread of ¬±45¬∞
    const speed = 300 + Math.random() * 200;
    trophy.vx = Math.cos(angle) * speed;
    trophy.vy = Math.sin(angle) * speed;
    wheel.appendChild(trophy);
    trophies.add(trophy);
    if (lastTime === null) {
      lastTime = performance.now();
      requestAnimationFrame(updateTrophies);
    }
  }

  function updateTrophies(time) {
    const dt = (time - lastTime) / 1000;
    lastTime = time;
    trophies.forEach((t) => {
      t.vy += GRAVITY * dt;
      t.x += t.vx * dt;
      t.y += t.vy * dt;
      t.style.transform = `translate(-50%, -50%) translate(${t.x}px, ${t.y}px)`;
      if (t.y > wheel.clientHeight / 2 + 100) {
        t.remove();
        trophies.delete(t);
      }
    });
    if (trophies.size) {
      requestAnimationFrame(updateTrophies);
    } else {
      lastTime = null;
    }
  }

  thumbUp.addEventListener('pointerdown', () => {
    spawnTrophy();
    playBubble();
  });
  const radius = 35; // circle radius in vmin
  const baseSize = Math.min(8, 60 / Math.max(emojis.length, 1));
  const fontSize = baseSize * 1.25; // make emojis 25% larger

  emojis.forEach((e, idx) => {
    const wrapper = document.createElement('span');
    wrapper.className = 'emoji-wrapper';
    const angle = (360 / emojis.length) * idx;
    wrapper.style.setProperty('--angle', `${angle}deg`);
    wrapper.style.setProperty('--radius', `${radius}vmin`);

    const span = document.createElement('span');
    span.className = 'emoji';
    span.textContent = e;
    span.style.fontSize = `clamp(3.75rem, ${fontSize}vmin, 10rem)`;

    wrapper.appendChild(span);
    container.appendChild(wrapper);
    wrappers.push(span);
  });

  const spinDuration = 600;
  const overlap = 0.5; // start next spin when current is 50% done
  function wave(i = 0) {
    if (!wrappers.length) return;
    const el = wrappers[i];
    el.classList.add('spin');
    setTimeout(() => el.classList.remove('spin'), spinDuration);
    setTimeout(() => wave((i + 1) % wrappers.length), spinDuration * overlap);
  }

  wave();

  menuBtn.addEventListener('click', () => {
    sessionStorage.removeItem('wordLimit');
    sessionStorage.removeItem('wordHistory');
    stopConfetti();
    window.location.href = '../';
  });

  window.addEventListener('pagehide', stopConfetti);
});
```

#### `settings/index.html`
Settings page for word length and preview mode preferences.

```
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Param√®tres</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titan+One&family=Nunito:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/base.css">
  <link rel="stylesheet" href="css/settings.css">
</head>
<body>
  <h1 class="titan-one-regular">Param√®tres</h1>

  <section class="option-group nunito-regular">
    <h2 class="nunito-regular">Longueur des mots</h2>
    <select id="wordLength" name="wordLength" class="nunito-regular">
      <option value="short" data-short="Mots courts" data-long="Mots courts uniquement">Mots courts</option>
      <option value="mixed" data-short="Tous les mots" data-long="Tous les mots">Tous les mots</option>
      <option value="long" data-short="Mots longs" data-long="Mots longs uniquement">Mots longs</option>
    </select>
  </section>

  <section class="option-group nunito-regular">
    <h2 class="nunito-regular">Pr√©visualisation des lettres</h2>
    <select id="previewMode" name="previewMode" class="nunito-regular">
      <option value="full" data-short="Complet" data-long="Aper√ßu complet">Aper√ßu complet</option>
      <option value="partial" data-short="Partiel" data-long="Aper√ßu partiel">Aper√ßu partiel</option>
      <option value="none" data-short="Aucun" data-long="Aucun aper√ßu">Aucun aper√ßu</option>
    </select>
  </section>

  <button id="back" class="btn options back-btn nunito-regular">Retour</button>

  <script src="js/settings.js"></script>
  <script src="../sw-register.js"></script>
</body>
</html>
```

#### `settings/css/settings.css`
Card-style styling for the settings page controls.

```
/* Settings page styles */
body {
  padding: 2rem;
  font-family: "Nunito", sans-serif;
  background: #f7f7f5;
}

h1 {
  color: #ff9966;
  text-align: center;
  margin-top: 0;
}

.option-group {
  margin: 2rem 0;
}

.option-group h2 {
  margin-bottom: 0.5rem;
  font-size: 1.5rem;
  font-weight: 600;
  color: #333;
}

.option-group select {
  appearance: none;
  border: none;
  outline: none;
  font: inherit;
  width: 100%;
  padding: 0.75rem 2.5rem 0.75rem 1rem;
  border-radius: 8px;
  background: #fff url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23333' viewBox='0 0 320 512'%3E%3Cpath d='M31.3 192h257.4c28.4 0 42.8 34.5 22.6 54.6L182.6 375.4c-12.5 12.5-32.8 12.5-45.3 0L8.7 246.6C-11.6 226.5 2.8 192 31.3 192z'/%3E%3C/svg%3E") no-repeat right 0.8rem center/1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: pointer;
}

.option-group select option {
  color: #333;
}

.option-group select:focus {
  outline: none;
}

.back-btn {
  margin: 2rem auto 0;
  display: block;
}

/* button styles moved to base.css */
```

#### `settings/js/settings.js`
Persists and previews select inputs for saved settings.

```
window.addEventListener('DOMContentLoaded', () => {
  const setupSelect = (id, storageKey, defaultValue) => {
    const select = document.getElementById(id);
    const saved = localStorage.getItem(storageKey) || defaultValue;
    select.value = saved;

    const showLongOptions = () => {
      Array.from(select.options).forEach((opt) => {
        if (opt.dataset.long) {
          opt.textContent = opt.dataset.long;
        }
      });
    };

    const setPreview = () => {
      showLongOptions();
      const selected = select.selectedOptions[0];
      if (selected && selected.dataset.short) {
        selected.textContent = selected.dataset.short;
      }
    };

    select.addEventListener('focus', showLongOptions);
    select.addEventListener('change', () => {
      localStorage.setItem(storageKey, select.value);
      setPreview();
    });
    select.addEventListener('blur', setPreview);

    setPreview();
  };

  setupSelect('wordLength', 'wordLength', 'mixed');
  setupSelect('previewMode', 'previewMode', 'full');

  const backBtn = document.getElementById('back');
  backBtn.addEventListener('click', () => {
    window.location.href = '../';
  });
});
```

